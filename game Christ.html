<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Christmas Maze 3D - Progressive Levels</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <style>
        /* --- FIX: Ensure HTML and Body take up the whole screen without margins --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
        }
        
        /* --- Ensure the canvas fills the entire viewport --- */
        canvas { 
            display: block;
            width: 100%; 
            height: 100%;
        }
        
        /* --- Overlay Text Positioning --- */
        #overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000000;
            z-index: 10;
            pointer-events: none;
        }
        #fps {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: sans-serif;
            font-size: 18px;
            text-shadow: 1px 1px 2px #000000;
            z-index: 10;
            pointer-events: none;
        }

        /* --- Brightness Slider Container --- */
        #brightness-control {
            position: absolute;
            top: 40px; /* Below FPS counter */
            right: 10px;
            z-index: 10;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            color: white;
            font-family: sans-serif;
            font-size: 14px;
        }
        #brightness-control label {
            display: block;
            margin-bottom: 5px;
        }
        
        /* --- NEW: Level Selector Menu Styling --- */
        #level-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 30px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #c90000;
            border-radius: 10px;
            color: white;
            font-family: sans-serif;
            text-align: center;
            display: none; /* Hidden by default */
        }
        #level-selector button {
            display: block;
            width: 150px;
            padding: 10px;
            margin: 10px auto;
            background-color: #007f00;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        #level-selector button:hover {
            background-color: #009900;
        }
    </style>
</head>
<body>

<div id="overlay">Level 1 | Bulbs Collected: 0 / 10 (Press SHIFT to Run, F to Toggle Fly Mode, Q/E for Vertical Flight)</div>
<div id="fps">FPS: 0</div>

<div id="brightness-control">
    <label for="ambient-slider">Ambient Brightness: <span id="brightness-percent">60%</span></label>
    <input type="range" id="ambient-slider" min="0.01" max="1.0" step="0.01" value="0.6">
</div>
<div id="level-selector">
    <h2>Select Level (1 - 5)</h2>
    <div id="level-buttons">
        </div>
    <p style="font-size: 12px; margin-top: 20px;">Press P to resume game.</p>
</div>
<script>
/* -------------------------------------------------------
    CONSTANTS AND INITIAL SETUP
------------------------------------------------------- */
const CELL = 4.5;
// Base Maze Dimensions (must be odd numbers)
const BASE_W = 31; 
const BASE_H = 31;

let W, H; // Current Maze Dimensions
let NUM_BULBS; // Current required bulbs
const PLAYER_HEIGHT = 2;
const NUM_ENEMIES = 4;
let mazeSeed = Date.now();
let originalLevelSeed = mazeSeed;
let currentLevel = 1; // Start at Level 1

// NEW: Pause state
let isPaused = false; 
let animationFrameId = null;

// Level progression data
const LEVEL_SETTINGS = [
    { level: 1, sizeMultiplier: 1, bulbCount: 10, ambientIntensity: 0.6 },
    { level: 2, sizeMultiplier: 1.25, bulbCount: 20, ambientIntensity: 0.4 },
    { level: 3, sizeMultiplier: 1.5, bulbCount: 30, ambientIntensity: 0.25 },
    { level: 4, sizeMultiplier: 1.75, bulbCount: 40, ambientIntensity: 0.15 },
    { level: 5, sizeMultiplier: 2.0, bulbCount: 50, ambientIntensity: 0.05 },
];
const MAX_LEVEL = LEVEL_SETTINGS.length;
let currentSettings = LEVEL_SETTINGS[0];

const scene = new THREE.Scene();
// Set initial background color to match the initial slider value (daylight blue)
scene.background = new THREE.Color(0x87CEEB); 

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const cameraHolder = new THREE.Object3D();
cameraHolder.add(camera);
scene.add(cameraHolder);

let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let moveUp = false; 
let moveDown = false; 
let isRunning = false; 

let yaw = 0, pitch = 0;
let isFlying = false; 
let gravity = 0.015;
let jumpVelocity = 0, isJumping = false, isFalling = false;

let walls = [];
let bulbs = []; // Collectible bulbs
let enemies = [];
let collected = 0;
let portal;
let treeLights = []; // Decorative tree lights (max 50)
let christmasTree;
let portalCubeCenter; // The invisible cube's center

// FPS Counter variables
let lastTime = 0;
let frameCount = 0;
let fps = 0;

// Define the three specific RGB colors for the decorative lights
const RGB_COLORS = [
    new THREE.Color(0xFF0000), // Red
    new THREE.Color(0x00FF00), // Green
    new THREE.Color(0x0000FF)  // Blue
];

// Trunk and Cone Dimensions
const TRUNK_VISIBLE_HEIGHT = 1.5; 
const TRUNK_RADIUS = 0.8; 
const CONE_HEIGHT = CELL * 3; 
const CONE_BASE_RADIUS = CELL * 1.0; 

// WALL DIMENSIONS (Reverted to thick blocks)
const WALL_WIDTH = CELL; 
const WALL_HEIGHT = CELL * 2.5; 

/* -------------------------------------------------------
    LIGHTING SETUP
------------------------------------------------------- */
// Ambient and Sun lights
const ambient = new THREE.AmbientLight(0xffffff, currentSettings.ambientIntensity); // Initial Intensity
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(50,100,50);
scene.add(sun);

// Initialize slider
document.getElementById('ambient-slider').value = currentSettings.ambientIntensity;

/* -------------------------------------------------------
    UTILITY FUNCTIONS
------------------------------------------------------- */
function seededRandom(max, min = 0) {
    mazeSeed = (mazeSeed * 9301 + 49297) % 233280;
    let rnd = mazeSeed / 233280;
    return Math.floor(min + rnd * (max - min));
}

function updateFPS(time) {
    frameCount++;
    const delta = time - lastTime;
    if (delta >= 1000) {
        fps = Math.round(frameCount / (delta / 1000));
        document.getElementById('fps').textContent = `FPS: ${fps}`;
        lastTime = time;
        frameCount = 0;
    }
}

function disposeMeshes(object) {
    if (object.geometry) object.geometry.dispose();
    if (object.material) {
        if (Array.isArray(object.material)) {
            object.material.forEach(m => m.dispose());
        } else {
            object.material.dispose();
        }
    }
}

function resetLevel(newLevel = currentLevel, nextLevel = false) {
    let newSeed = Date.now();
    
    // Determine the level setting
    if (nextLevel && newLevel < MAX_LEVEL) {
        currentLevel = newLevel + 1;
        originalLevelSeed = newSeed; 
    } else if (nextLevel && newLevel === MAX_LEVEL) {
        alert("CONGRATULATIONS! You completed the final level!");
        currentLevel = 1; // Loop back to level 1 for replayability
        originalLevelSeed = newSeed; 
    } else if (newLevel !== currentLevel) {
        // Direct level selection (e.g., from the selector menu)
        currentLevel = newLevel;
        originalLevelSeed = newSeed; 
    } else if (!nextLevel) {
        // Death restart or simple reset, keep original seed
        newSeed = originalLevelSeed; 
    }

    currentSettings = LEVEL_SETTINGS.find(s => s.level === currentLevel);
    
    // Update global variables
    W = Math.max(3, Math.floor(BASE_W * currentSettings.sizeMultiplier / 2) * 2 + 1);
    H = Math.max(3, Math.floor(BASE_H * currentSettings.sizeMultiplier / 2) * 2 + 1);
    NUM_BULBS = currentSettings.bulbCount;
    
    // Set ambient light and percentage display
    const initialIntensity = parseFloat(document.getElementById('ambient-slider').value);
    ambient.intensity = initialIntensity; 
    document.getElementById('brightness-percent').textContent = `${Math.round(initialIntensity * 100)}%`; 
    
    document.getElementById('overlay').textContent = `Level ${currentLevel} | Bulbs Collected: 0 / ${NUM_BULBS} (Press SHIFT to Run, F to Toggle Fly Mode, Q/E for Vertical Flight)`;

    // Clear and dispose resources
    const objectsToKeep = [cameraHolder, ambient, sun];
    for(let i = scene.children.length - 1; i >= 0; i--) {
        let obj = scene.children[i];
        if (!objectsToKeep.includes(obj)) {
            scene.remove(obj); 
            if (obj.isGroup) {
                obj.children.forEach(disposeMeshes);
            }
            disposeMeshes(obj);
        }
    }
    
    // Clear arrays
    walls.length = 0;
    bulbs.length = 0;
    enemies.length = 0;
    treeLights.length = 0; 
    collected = 0;
    
    mazeSeed = newSeed;
    enemyPaths.clear(); 
    
    // Restart animation loop if it was paused
    if (isPaused) {
        togglePause();
    }

    setTimeout(initGame, 0); 
}

function generateMaze(w, h) {
    let maze = Array.from({length: h}, () => Array(w).fill(1));

    function carve(x, y) {
        maze[y][x] = 0;
        let dirs = [[2,0],[-2,0],[0,2],[0,-2]].sort(() => Math.random()-0.5);
        for (let [dx,dy] of dirs) {
            let nx = x+dx, ny = y+dy;
            if (nx>0 && nx<w-1 && ny>0 && ny<h-1 && maze[ny][nx] === 1) {
                maze[y+dy/2][x+dx/2] = 0;
                carve(nx,ny);
            }
        }
    }

    carve(1,1);
    
    // Create the square center open area
    const centerSize = 7;
    const centerStart = Math.floor((w - centerSize) / 2);
    for (let y = 0; y < centerSize; y++) {
        for (let x = 0; x < centerSize; x++) {
            let cx = centerStart + x;
            let cy = centerStart + y;
            if (cx > 0 && cx < w - 1 && cy > 0 && cy < h - 1) {
                maze[cy][cx] = 0; 
            }
        }
    }
    
    // Level 4+ Maze Trapping
    if (currentLevel >= 4) {
        const trapChance = currentLevel * 0.005; // 4: 2%, 5: 2.5% chance per walkable cell
        const playerStartX = 1;
        const playerStartY = 1;
        
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                if (maze[y][x] === 0 && (x !== playerStartX || y !== playerStartY) &&
                    (x % 2 !== 0 || y % 2 !== 0)) {
                    
                    if (Math.random() < trapChance) {
                        maze[y][x] = 1; 
                        
                        // Increase the trapping effect
                        if (x % 2 === 1 && y % 2 === 0 && x + 1 < w - 1) maze[y][x+1] = 1; 
                        if (x % 2 === 0 && y % 2 === 1 && y + 1 < h - 1) maze[y+1][x] = 1; 
                    }
                }
            }
        }
    }
    
    return maze;
}

let currentMaze;

/* -------------------------------------------------------
    MATERIALS (Festive Colors)
------------------------------------------------------- */
const wallMat = new THREE.MeshLambertMaterial({color: 0xc90000});
const floorMat = new THREE.MeshLambertMaterial({color: 0x007f00});
const baseBulbMat = new THREE.MeshLambertMaterial({emissive: 0x000000}); 
const enemyMat = new THREE.MeshLambertMaterial({color:0xdd0000});
const portalMat = new THREE.MeshLambertMaterial({color:0x00ffee, emissive:0x00ffee, side: THREE.DoubleSide, transparent: true, opacity: 0.8});
const wireMat = new THREE.LineBasicMaterial({color: 0x888888, linewidth: 3});
const treeMat = new THREE.MeshLambertMaterial({color: 0x003f00});
const unlitTreeLightMat = new THREE.MeshLambertMaterial({
    color: 0x333333, 
    emissive: 0x000000
});

/* -------------------------------------------------------
    BUILD MAZE & TREE
------------------------------------------------------- */
function createChristmasTree() {
    
    const centerSize = 7;
    const centerMiddle = Math.floor((W - centerSize) / 2) + Math.floor(centerSize / 2);
    const treeWorldX = centerMiddle * CELL;
    const treeWorldZ = centerMiddle * CELL;
    portalCubeCenter = new THREE.Vector3(treeWorldX, 0, treeWorldZ);

    // 1. Trunk
    const trunkHeight = TRUNK_VISIBLE_HEIGHT;
    const trunkGeo = new THREE.CylinderGeometry(TRUNK_RADIUS, TRUNK_RADIUS, trunkHeight, 16); 
    const trunkMat = new THREE.MeshLambertMaterial({color: 0x582900});
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.set(treeWorldX, trunkHeight / 2, treeWorldZ);

    // 2. Cone
    const coneStartHeight = trunkHeight; 
    const coneTotalHeight = CONE_HEIGHT; 
    const treeBaseRadius = CONE_BASE_RADIUS; 
    const coneGeo = new THREE.ConeGeometry(treeBaseRadius, coneTotalHeight, 32);
    const cone = new THREE.Mesh(coneGeo, treeMat);
    cone.position.set(treeWorldX, coneStartHeight + coneTotalHeight / 2, treeWorldZ);
    
    christmasTree = new THREE.Group();
    christmasTree.add(cone);
    christmasTree.add(trunk);
    christmasTree.isCollidable = true; 
    christmasTree.collisionRadius = CONE_BASE_RADIUS * 0.9;
    scene.add(christmasTree);
}

function buildMaze(maze) {
    const floorGeo = new THREE.PlaneGeometry(CELL, CELL);
    const wallGeo = new THREE.BoxGeometry(WALL_WIDTH, WALL_HEIGHT, WALL_WIDTH);
    
    for (let y=0; y<H; y++) {
        for (let x=0; x<W; x++) {

            let wx = x * CELL;
            let wz = y * CELL;

            // Floor
            let f = new THREE.Mesh(floorGeo, floorMat);
            f.rotation.x = -Math.PI/2;
            f.position.set(wx, 0, wz);
            scene.add(f);

            // Wall check: Place a solid wall block if maze[y][x] is 1
            if (maze[y][x] === 1) {
                let w = new THREE.Mesh(wallGeo, wallMat);
                w.position.set(wx, WALL_HEIGHT / 2, wz); 
                w.isCollidable = true;
                w.collisionSizeX = WALL_WIDTH / 2;
                w.collisionSizeZ = WALL_WIDTH / 2;
                scene.add(w);
                walls.push(w);
            }
        }
    }
    
    createChristmasTree(); 
}

function decorateChristmasTree() {
    if (!christmasTree) return;

    const cone = christmasTree.children.find(c => c.geometry.type === 'ConeGeometry');
    if (!cone) return;

    const coneTotalHeight = cone.geometry.parameters.height;
    const treeBaseRadius = cone.geometry.parameters.radius; 
    const treePos = cone.position; 

    // Use current NUM_BULBS as total lights, up to a sensible limit (e.g., 50)
    const totalLights = Math.min(NUM_BULBS, 50); 
    const numTurns = 7; 
    const lightGeo = new THREE.SphereGeometry(0.1, 8, 8); 

    let spiralPoints = []; 

    const detail = 50; 
    const numWireSegments = detail * numTurns; 
    const CONE_BOTTOM_Y = cone.position.y - (coneTotalHeight / 2); 

    for (let i = 0; i <= numWireSegments; i++) {
        const heightRatio = i / numWireSegments;
        const angle = heightRatio * Math.PI * 2 * numTurns; 

        const y = CONE_BOTTOM_Y + heightRatio * coneTotalHeight; 
        const radiusRatio = (1 - heightRatio);
        const currentRadius = treeBaseRadius * radiusRatio * 1.05; 

        const x = treePos.x + currentRadius * Math.cos(angle);
        const z = treePos.z + currentRadius * Math.sin(angle);

        spiralPoints.push(new THREE.Vector3(x, y, z));
    }

    const curve = new THREE.CatmullRomCurve3(spiralPoints);
    const wireGeometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(numWireSegments * 3));
    const line = new THREE.Line(wireGeometry, wireMat);
    scene.add(line);
    
    for (let i = 0; i < totalLights; i++) {
        const t = i / totalLights; 
        const lightPos = curve.getPointAt(t);

        const individualLightMat = unlitTreeLightMat.clone();
        
        const bulb = new THREE.Mesh(lightGeo, individualLightMat);
        bulb.position.copy(lightPos);
        scene.add(bulb);
        treeLights.push(bulb); 
    }
}

function spawnBulbs(maze) {
    const bulbGeo = new THREE.SphereGeometry(0.5,16,16);
    const centerSize = 7;
    const centerStart = Math.floor((W - centerSize) / 2); 
    const centerEnd = centerStart + centerSize - 1; 

    while (bulbs.length < NUM_BULBS) {
        let x = seededRandom(W);
        let y = seededRandom(H);
        
        const isInCenter = (x >= centerStart && x <= centerEnd && y >= centerStart && y <= centerEnd);

        if (maze[y][x] === 0 && (x !== 1 || y !== 1) && !isInCenter) { 
            
            // --- Assign RGB Color to Collectible Bulb ---
            const colorIndex = seededRandom(RGB_COLORS.length);
            const rgbColor = RGB_COLORS[colorIndex];

            const bulbMat = baseBulbMat.clone();
            bulbMat.color.copy(rgbColor);
            bulbMat.emissive.copy(rgbColor).multiplyScalar(0.7);

            let b = new THREE.Mesh(bulbGeo, bulbMat);
            b.position.set(x*CELL, 1.2, y*CELL);
            scene.add(b);
            bulbs.push(b);
        }
    }
}

function spawnEnemies(maze) {
    const enemyGeo = new THREE.BoxGeometry(1, 1.8, 1);
    // Keep a constant number of enemies for all levels
    while (enemies.length < NUM_ENEMIES) { 
        let x = seededRandom(W);
        let y = seededRandom(H);
        if (maze[y][x] === 0 && (x !== 1 || y !== 1)) {
            let e = new THREE.Mesh(enemyGeo, enemyMat);
            e.position.set(x*CELL, 0.9, y*CELL);
            scene.add(e);
            enemies.push(e);
        }
    }
}

function createPortal() {
    const portalWidth = 3;
    const portalHeight = 5;
    
    // Portal Cube Size: CONE_BASE_RADIUS + Buffer to ensure it clears the tree base
    const cubeSide = CONE_BASE_RADIUS * 1.5 + 1.0; 

    portal = new THREE.Mesh(new THREE.PlaneGeometry(portalWidth, portalHeight), portalMat); 
    portal.position.y = portalHeight / 2 + 0.05; 
    portal.visible = false;

    // 1. Choose a random side (0=N, 1=E, 2=S, 3=W)
    const side = seededRandom(4);

    let offsetX = 0, offsetZ = 0, rotationY = 0;
    
    // Position the portal flush against the outside of the invisible cube
    switch (side) {
        case 0: // North side (+Z)
            offsetZ = cubeSide / 2 + portalWidth / 2; // Move out by half cube side + half portal width
            rotationY = 0; // Faces -Z
            break;
        case 1: // East side (+X)
            offsetX = cubeSide / 2 + portalWidth / 2;
            rotationY = Math.PI / 2; // Faces -X
            break;
        case 2: // South side (-Z)
            offsetZ = -(cubeSide / 2 + portalWidth / 2);
            rotationY = Math.PI; // Faces +Z
            break;
        case 3: // West side (-X)
            offsetX = -(cubeSide / 2 + portalWidth / 2);
            rotationY = -Math.PI / 2; // Faces +X
            break;
    }

    portal.position.x = portalCubeCenter.x + offsetX;
    portal.position.z = portalCubeCenter.z + offsetZ;
    portal.rotation.y = rotationY; 

    scene.add(portal);
}

function initGame() {
    // Set level parameters
    W = Math.max(3, Math.floor(BASE_W * currentSettings.sizeMultiplier / 2) * 2 + 1);
    H = Math.max(3, Math.floor(BASE_H * currentSettings.sizeMultiplier / 2) * 2 + 1);
    NUM_BULBS = currentSettings.bulbCount;
    // Ambient light is set by slider
    ambient.intensity = parseFloat(document.getElementById('ambient-slider').value); 

    // Regenerate and build the maze
    currentMaze = generateMaze(W,H);
    buildMaze(currentMaze);
    decorateChristmasTree(); 
    spawnBulbs(currentMaze); 
    spawnEnemies(currentMaze);
    createPortal();
    
    // Reset player position to start cell (1, 1)
    cameraHolder.position.set(CELL, PLAYER_HEIGHT, CELL);
    cameraHolder.rotation.y = 0;
    camera.rotation.x = 0;
    yaw = 0;
    pitch = 0;
}

// Initial setup call
initGame();

// NEW: Function to toggle pause state and menu visibility
function togglePause() {
    isPaused = !isPaused;
    const selector = document.getElementById('level-selector');
    
    if (isPaused) {
        // Show menu and prevent movement
        selector.style.display = 'block';
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        document.exitPointerLock(); // Release mouse lock
    } else {
        // Hide menu and resume game
        selector.style.display = 'none';
        if (animationFrameId === null) {
            animate(0); // Restart the loop
        }
        document.body.requestPointerLock(); // Re-lock mouse
    }
}

// NEW: Dynamically create level buttons
function createLevelSelectorButtons() {
    const container = document.getElementById('level-buttons');
    LEVEL_SETTINGS.forEach(setting => {
        const button = document.createElement('button');
        button.textContent = `Level ${setting.level}`;
        button.onclick = () => {
            // Reset the maze with the selected level
            resetLevel(setting.level); 
        };
        container.appendChild(button);
    });
}
createLevelSelectorButtons();

/* --- Window Resizing --- */
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
window.addEventListener('resize', onWindowResize, false);

/* --- Ambient Brightness Slider Event (Changes Sky Color and Percentage) --- */
document.getElementById('ambient-slider').addEventListener('input', (event) => {
    const intensity = parseFloat(event.target.value);
    
    // 1. Update Ambient Light
    ambient.intensity = intensity;

    // 2. Update Percentage Display
    document.getElementById('brightness-percent').textContent = `${Math.round(intensity * 100)}%`;

    // 3. Interpolate Sky Color (Blue to Black)
    const baseColor = new THREE.Color(0x000000); // Black (Night)
    const targetColor = new THREE.Color(0x87CEEB); // Sky Blue (Day)
    const t = Math.max(0, Math.min(1, intensity * 1.5)); 
    
    const newColor = baseColor.clone().lerp(targetColor, t);
    scene.background = newColor;

    // 4. Adjust Directional Light (Sun) visibility
    sun.visible = intensity > 0.1;
});

/* -------------------------------------------------------
    INPUT & COLLISION
------------------------------------------------------- */
document.addEventListener('keydown', e => {
    // P Key to Pause/Open Selector
    if (e.code === 'KeyP') {
        togglePause();
        return; 
    }
    
    // Only process movement keys if not paused
    if (isPaused) return;

    if (e.code === 'KeyW') moveForward = true;
    if (e.code === 'KeyS') moveBackward = true;
    if (e.code === 'KeyA') moveLeft = true;
    if (e.code === 'KeyD') moveRight = true;
    if (e.code === 'KeyQ') moveUp = true;
    if (e.code === 'KeyE') moveDown = true;
    // Shift to Run
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isRunning = true;
    
    // Fly mode toggle on 'F'
    if (e.code === 'KeyF') { 
          isFlying = !isFlying;
          if (!isFlying) {
            cameraHolder.position.y = PLAYER_HEIGHT;
            isJumping = false;
            isFalling = false;
          }
    }

    if (e.code === 'Space' && !isFlying && !isJumping && !isFalling) {
        isJumping = true;
        jumpVelocity = 0.5;
    }
});

document.addEventListener('keyup', e => {
    if (e.code === 'KeyW') moveForward = false;
    if (e.code === 'KeyS') moveBackward = false;
    if (e.code === 'KeyA') moveLeft = false;
    if (e.code === 'KeyD') moveRight = false;
    if (e.code === 'KeyQ') moveUp = false;
    if (e.code === 'KeyE') moveDown = false;
    // Stop Running
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isRunning = false;
});

document.addEventListener("mousemove", e => {
    if (document.pointerLockElement !== document.body || isPaused) return;
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    cameraHolder.rotation.y = yaw;
    camera.rotation.x = pitch;
});

document.body.addEventListener("click", () => {
    // Only request pointer lock if the game is not paused
    if (!isPaused) {
        document.body.requestPointerLock();
    }
});

function checkTreeCollision(x, z, radius) {
    if (!christmasTree || !christmasTree.isCollidable) return false;

    const treeCenter = new THREE.Vector3(christmasTree.position.x, 0, christmasTree.position.z);
    const playerCenter = new THREE.Vector3(x, 0, z);
    const distance = treeCenter.distanceTo(playerCenter);
    
    return distance < (christmasTree.collisionRadius + radius);
}

function canMoveTo(x, z, radius = 0.5) {
    if (isFlying) return true; 

    // 1. Check Maze Walls
    for (let w of walls) {
        if (Math.abs(w.position.x - x) < w.collisionSizeX + radius &&
            Math.abs(w.position.z - z) < w.collisionSizeZ + radius) {
            return false;
        }
    }

    // 2. Check Christmas Tree
    if (checkTreeCollision(x, z, radius)) {
        return false;
    }
    
    return true;
}

function worldToMaze(pos) {
    return {
        x: Math.round(pos.x / CELL),
        y: Math.round(pos.z / CELL)
    };
}

function findPath(start, end, maze) {
    let queue = [{ pos: start, path: [] }];
    let visited = Array.from({length: H}, () => Array(W).fill(false));

    while (queue.length > 0) {
        let { pos, path } = queue.shift();
        
        if (pos.x === end.x && pos.y === end.y) {
            return path;
        }

        if (pos.x < 0 || pos.x >= W || pos.y < 0 || pos.y >= H || visited[pos.y][pos.x] || maze[pos.y][pos.x] === 1) {
            continue;
        }
        visited[pos.y][pos.x] = true;

        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (let [dx, dy] of directions) {
            let nextPos = { x: pos.x + dx, y: pos.y + dy };
            let newPath = [...path, nextPos];
            queue.push({ pos: nextPos, path: newPath });
        }
    }
    return null;
}

let enemyPaths = new Map();

/* -------------------------------------------------------
    GAME LOOP
------------------------------------------------------- */
function animate(time) {
    // Stop the loop if paused
    if (isPaused) {
        animationFrameId = null;
        return;
    }
    
    animationFrameId = requestAnimationFrame(animate);

    // Update FPS Counter
    updateFPS(time);

    // Dynamic Speed based on running state
    let baseSpeed = 0.1;
    let runMultiplier = 2.5; 
    const speed = isFlying ? 0.3 : (isRunning ? baseSpeed * runMultiplier : baseSpeed);

    let newPos = cameraHolder.position.clone();

    /* ----- Player Movement ----- */
    let deltaX = 0, deltaZ = 0;
    if (moveForward) {
        deltaX -= Math.sin(yaw) * speed;
        deltaZ -= Math.cos(yaw) * speed;
    }
    if (moveBackward) {
        deltaX += Math.sin(yaw) * speed;
        deltaZ += Math.cos(yaw) * speed;
    }
    if (moveLeft) {
        deltaX -= Math.cos(yaw) * speed;
        deltaZ += Math.sin(yaw) * speed;
    }
    if (moveRight) {
        deltaX += Math.cos(yaw) * speed;
        deltaZ -= Math.sin(yaw) * speed;
    }

    newPos.x += deltaX;
    newPos.z += deltaZ;
    
    // Collision check
    if (canMoveTo(newPos.x, cameraHolder.position.z)) {
        cameraHolder.position.x = newPos.x;
    } 
    if (canMoveTo(cameraHolder.position.x, newPos.z)) {
        cameraHolder.position.z = newPos.z;
    }
    
    // Vertical movement/gravity... 
    if (isFlying) {
        if (moveUp) {
            cameraHolder.position.y += speed;
        }
        if (moveDown) {
            cameraHolder.position.y = Math.max(0.1, cameraHolder.position.y - speed); 
        }
    } else {
        if (isJumping || isFalling) {
            cameraHolder.position.y += jumpVelocity;
            jumpVelocity -= gravity;
        }
        if (cameraHolder.position.y <= PLAYER_HEIGHT) {
            cameraHolder.position.y = PLAYER_HEIGHT;
            isJumping = false;
            isFalling = false;
        } else {
            isFalling = true;
        }
    }
    
    /* ----- Bulb collection and Tree Light Update ----- */
    for (let i=bulbs.length-1; i>=0; i--) {
        if (cameraHolder.position.distanceTo(bulbs[i].position) < 1.5) {
            scene.remove(bulbs[i]);
            disposeMeshes(bulbs[i]);
            bulbs.splice(i,1);
            collected++;
            document.getElementById('overlay').textContent = `Level ${currentLevel} | Bulbs Collected: ${collected} / ${NUM_BULBS} (Press SHIFT to Run, F to Toggle Fly Mode, Q/E for Vertical Flight)`;
            
            // Light up a decorative tree light
            if (collected > 0 && collected <= treeLights.length) {
                const lightIndex = collected - 1; 
                const treeLight = treeLights[lightIndex];
                
                const colorIndex = seededRandom(RGB_COLORS.length);
                const rgbColor = RGB_COLORS[colorIndex];

                treeLight.material.color.copy(rgbColor);
                treeLight.material.emissive.copy(rgbColor).multiplyScalar(0.7);
            }
            
            if (collected === NUM_BULBS) portal.visible = true;
        }
    }

    /* ----- Enemies movement and Collision ----- */
    enemies.forEach(e => {
        const enemySpeed = 0.05;
        
        let startCell = worldToMaze(e.position);
        let targetCell = worldToMaze(cameraHolder.position);
        
        let currentPath = enemyPaths.get(e);
        if (!currentPath || currentPath.length === 0 || 
            (currentPath.length > 0 && 
             Math.abs(e.position.x - currentPath[0].x * CELL) < 0.1 && 
             Math.abs(e.position.z - currentPath[0].y * CELL) < 0.1)) {
             
             currentPath = findPath(startCell, targetCell, currentMaze);
             enemyPaths.set(e, currentPath || []);
        }

        if (currentPath && currentPath.length > 0) {
            let nextCell = currentPath[0];
            let targetWorldX = nextCell.x * CELL;
            let targetWorldZ = nextCell.y * CELL;
            
            let dir = new THREE.Vector3(targetWorldX, e.position.y, targetWorldZ).sub(e.position).normalize();
            e.position.addScaledVector(dir, enemySpeed);

            if (e.position.distanceTo(new THREE.Vector3(targetWorldX, e.position.y, targetWorldZ)) < enemySpeed * 2) {
                currentPath.shift();
                enemyPaths.set(e, currentPath);
            }
        }
        
        // Seamless Game Restart on Enemy Collision (Death)
        if (cameraHolder.position.distanceTo(e.position) < 1) {
            resetLevel(); 
            return;
        }
    });

    /* ----- Portal Win and Seamless Level Advance ----- */
    if (portal.visible) {
        if (cameraHolder.position.distanceTo(portal.position) < 2) {
            resetLevel(currentLevel, true);
            return;
        }
    }

    renderer.render(scene, camera);
}

// Start the animation loop initially
animate(0); 
</script>
</body> 
</html>
